## 系统启动

Boot ROM

BootLoader

idle(pid=0)

init(pid=1)

threadd(pid=2)

Zygote

SystemService

APP



进程 fork
线程 new Thread.start()

内核空间 kthread
用户空间 zygote

kernel/common/init/main.c --> kernel

try_to_run_init_

### init.cpp

FirstStageMain:
    
    1. 挂载 创建
    2. 重定向输入输出
    3. 初始化内核
    4. 启动 selinux_setup

SetupSelinux:

    1. linux 的安全策略

    second_stage --> SecondStageMain

SecondStageMain:

    1. 解析 init.rc
    2. 进入 while 循环
    3. 根据解析出来的 rc 命令语句 启动 zygote 进程 (app_process)

PropertyInit

    处理子进程的终止信号 --> 僵尸进程


zygote 进程 app_process app_main.cpp :
    
    1. zygote - native:
        1. 启动 运行时 环境 VM
        2. 注册 JNI
            2.1 静态注册 -> 符合 按照 JNI 规范的 ( Java_package_function() ) 命名规则进行查找, 叫静态注册;
            2.2 动态注册-> 在 JNI_OnLoad函数中调用 jniEnv.RegisterNatives 进行注册的
        3. 调用 vm.start -> 反射调用 ZygoteInit.main() 函数 启动 Java 的 Zygote 部分
    2. zygote - Java:
        1. 定义 ZygoteServer
        2. 预加载 进程 公用资源
        3. 初始化 ZygoteServer
        4. forkSystemServer (fork 之后 分 父进程(Zygote) 和 子进程(SystemServer) 两条分支继续执行)
        5. Zygote 进程
            5.1 调用 zygoteServer.runSelectLoop 创建 Runnable
            5.2 执行 runnable 等待 socket 客户端 链接  ZygoteConnection = acceptCommandPeer() -> createNewConnection()
        6. SystemServer 进程
            6.1 handleSystemServerProcess
            6.2 获取 SystemServer 的 类加载器 getOrCreateSystemServerClassLoader()
            6.3 ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,parsedArgs.mDisabledCompatChanges,parsedArgs.mRemainingArgs, cl)
            6.4 RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,classLoader)
            6.5 执行 SystemServer.main() 函数 启动 系统服务. findStaticMain(args.startClass, args.startArgs, classLoader);
            6.6 执行 new SystemServer().run() 函数
            6.7 创建系统上下文 createSystemContext()
                6.7.1 调用 ActivityThread.systemMain() 创建 ActivityThread
                    6.7.1.1 activityThread.attach(true,0)
                6.7.2 赋值 系统上下文 mSystemContext = activityThread.getSystemContext();
                    6.7.2.1 调用 ContextImpl.createSystemContext(this) 生成系统上下文
                    6.7.2.2 创建 packageInfo = new LoadedApk(mainThread); 创建 LoadedApk 解析 apk 文件
                    6.7.2.3 创建 上下文 context = new ContextImpl(null. mainThread, packageInfo)
                    6.7.2.4 context.setResuces(packageInfo.getResuces()) 给 context 设置资源
                    6.7.2.5 返回 context -> ContextImpl()
            6.8 创建 SystemServiceManager 注册 服务 Binder 并启动 (调用 服务的 onStart(方法))
            6.9 启动各种各样的系统服务
                6.9.1 startBootStrapServices(t) 启动引导启动服务  ATMS AMS PMS DMS PKMS
                6.9.2 startCoreServices(t) 启动系统核心服务 BatteryService
                6.9.3 startOtherServices(t) 启动其他服务 IMS WMS  
                6.9.4 startApexServices(t) 启动最后一个顶点服务 并保证在此之后, 不再启动其他服务


SystemServer 启动 AMS 流程:

    1.  ZygoteInit -> forkSystemServer() -> (return) Runnable
        ZygoteInit ->  handleSystemServerProcess -> (return) Runnable
            判断 (ZygoteArguments) parsedArgs.mInvokeWith == null
        ZygoteInit -> static zygoteInit -> (return) Runnable
            // 开启 binder 线程池
            -> ZygoteInit.nativeZygoteInit();
                -> gCurRuntime->onZygoteInit();
                    // app_main.cpp -> AppRuntime.onZygoteInit()
                    -> sp<ProcessState> proc = ProcessState::self();
                    -> proc->startThreadPool();
        RuntimeInit -> static applicationInit -> (return) Runnable
        // 最终 子进程 执行的 Runnable 就是 这个 MethodAndArgsCaller -> 调用 SystemServer.main() -> new SystemServer().run()
        RuntimeInit -> static findStaticMain(className, args, classLoader) -> return MethodAndArgsCaller()

    2.  SystemServer -> run() 函数
        2.1 初始化 Binder 配置
        2.2 创建系统上下文 createSystemContext()
            2.2.1 ActivityThread.systemMain() 调用 ActivityThread 的 systemMain 函数 构建 systemServer 的 ActivityThread()
                -> mSystemContext = activityThread.getSystemContext();
        // 创建 SystemServiceManager 构建 binder 管理系统服务 的创建 启动, 和生命周期
        2.3 mSystemServiceManager = new SystemServiceManager(mSystemContext); 
        2.4 启动系统所需的 系统服务
            2.4.1 启动引导启动的系统服务 startBootstrapServices(t)
                -> 启动 ATMS ( ActivityTaskManagerService ) Activity 的启动
                -> 启动 AMS ( ActivityManagerService ) 四大组件的 启动
                -> 启动 PMS ( PowerManagerService ) 电源管理服务
                -> 启动 DMS ( DisplayManagerService ) 显示屏管理
                -> 启动 PKMS ( PackageManagerServices ) 安装包管理
                -> 启动 SensorService 传感器服务
            2.4.2 启动核心的系统服务 startCoreServices(t)
                -> 启动 BatteryService 电池服务
            2.4.3 启动其他的系统服务 startOtherServices(t)
                -> 启动 IMS ( InputManagerService ) 输入管理服务
                -> 启动 WMS ( WindowManagerService ) 窗口管理服务 -> 给 AMS 配置 WMS
                -> 启动 ADB Service 调试桥 (Android Debug Bridge)
                -> 调用 ActivityManagerService 的 systemReady() 函数
            2.4.4 启动 顶点系统服务 startApexServices(t) 最后一个顶点服务, 禁止该服务之后再启动其他服务 ( Android 11 还没有 )
        2.5 Looper -> loop() 进入循环事件处理
    3. ATMS 启动
         -> ActivityTaskManagerService atm = mSystemServiceManager.startService(ActivityTaskManagerService.Lifecycle.class).getService()
            // 利用反射 创建 ActivityTaskManagerService.Lifecycle 内部类, 管理生命周期 Lifecycle 继承 SystemService 
            -> mSystemServiceManager.startService(ActivityTaskManagerService.Lifecycle.class)
                // 利用反射 创建 ActivityTaskManagerService 实例
                ->  Constructor<T> constructor = serviceClass.getConstructor(Context.class);
                    service = constructor.newInstance(mContext);
                // 内部调用重载函数 startService(SystemService)
                -> startService(service);
                // 注册到 把实例保存 到本地 维护 的List 中
                mServiceClassnames.add(className); // 保存名字
                mServices.add(service); // 保存实例
                // 调用服务实例的 onStart 方法
                service.onStart(); // ActivityTaskManagerService.Lifecycle.onStart()
                    -> publishBinderService 函数
                        -> ServiceManager.addService(name, service, allowIsolated, dumpPriority)
                        -> getIServiceManager().addService(name, service, allowIsolated, dumpPriority);
                        // getIServiceManager() 返回 ServiceManagerProxy 实例
                        -> ServiceManagerNative.asInterface(Binder.allowBlocking(BinderInternal.getContextObject())) -> ServiceManagerProxy()
                        -> ServiceManagerProxy().addService(name, service, allowIsolated, dumpPriority);
                    -> mService.start()
                        // 传递 mInternal = LocalService 继承 ActivityTaskManagerInternal -> 
                        -> LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);
                            -> (ArrayMap)sLocalServiceObjects.put(type, service);
         -> SystemServer.startOtherServices()
            // AMS -> ATMS -> 
            -> mActivityManagerService.systemReady(Runnable, TimingsTraceAndSlog)
                -> ActivityTaskManagerService.onSystemReady() // 准备之后算是正式启动完成

    4. 